{"meta":{"title":"AnQing","subtitle":"AnQing Blog","description":null,"author":null,"url":"http://anqingliu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-04-25T12:09:09.270Z","updated":"2019-04-25T12:09:09.270Z","comments":true,"path":"404.html","permalink":"http://anqingliu.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"404 Not Found","date":"2019-04-25T13:01:46.136Z","updated":"2019-04-25T13:01:46.136Z","comments":true,"path":"about/index.html","permalink":"http://anqingliu.github.io/about/index.html","excerpt":"","text":"关于我 一个安静的人待完善中…"},{"title":"一些必要的链接","date":"2019-04-27T08:06:44.911Z","updated":"2019-04-27T08:06:44.911Z","comments":true,"path":"friends/index.html","permalink":"http://anqingliu.github.io/friends/index.html","excerpt":"","text":"Anqingliu material-x博客主题"},{"title":"","date":"2019-04-25T12:07:07.913Z","updated":"2019-04-25T12:07:07.913Z","comments":true,"path":"mylist/index.html","permalink":"http://anqingliu.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-04-25T12:06:20.535Z","updated":"2019-04-25T12:06:20.535Z","comments":true,"path":"tags/index.html","permalink":"http://anqingliu.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2019-04-25T13:02:27.224Z","updated":"2019-04-25T13:02:27.224Z","comments":true,"path":"projects/index.html","permalink":"http://anqingliu.github.io/projects/index.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"eclipse的使用技巧","slug":"E_eclipse使用技巧","date":"2020-10-30T09:09:01.379Z","updated":"2020-11-02T02:22:25.623Z","comments":true,"path":"2020/10/30/E_eclipse使用技巧/","link":"","permalink":"http://anqingliu.github.io/2020/10/30/E_eclipse使用技巧/","excerpt":"汇总eclipse使用技巧 切换工作空间，拷贝相应工作空间的样式(未掌握)每一个项目建立一个工作空间。 File——-&gt;SwitchWorkspace 拷贝工作控件的样式. 将b工作空间的样式导入到a工作空间 原文章","text":"汇总eclipse使用技巧 切换工作空间，拷贝相应工作空间的样式(未掌握)每一个项目建立一个工作空间。 File——-&gt;SwitchWorkspace 拷贝工作控件的样式. 将b工作空间的样式导入到a工作空间 原文章 键盘小助手 显示行号(已掌握)Ctrl+F10 智能提示(已掌握)windows - Preferences - java - Editor - Content Assist 注释快捷键 Ctrl+/ Ctrl+Shift+/ Ctrl+Shift+\\ 消除/* */注释 Ⅰctrl+m切换窗口视图 使其编辑窗口最大化。 ctrl+F6切换到不同类的窗口中去 ctrl+shift+down快速复制一行或者几行 alert+shift+s -&gt; 选择Override/Implement Methods… -&gt; 选择你需要重写的方法重写父类快捷键 alt+shift+jJavadoc 注释 alt+shift+z导入模版,注意了要选中了 ctrl+shift+f4关闭编辑的窗口 shift+alt+r重命名 ctrl+q回到上一次的编辑点","categories":[{"name":"2020年10月","slug":"2020年10月","permalink":"http://anqingliu.github.io/categories/2020年10月/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://anqingliu.github.io/tags/工具/"}]},{"title":"Shell学习","slug":"S_Shell学习","date":"2020-10-27T12:46:30.047Z","updated":"2020-10-27T14:09:13.449Z","comments":true,"path":"2020/10/27/S_Shell学习/","link":"","permalink":"http://anqingliu.github.io/2020/10/27/S_Shell学习/","excerpt":"","text":"1234567891011#!/bin/shcd ~mkdir shell_tutcd shell_tutfor (( i = 0; i &lt; 10; i++ )); do #statements touch test_$i.txtdone&lt;!-- more --&gt; 第1行：指定脚本解释器，这里是用/bin/sh做解释器的 第2行：切换到当前用户的home目录 第3行：创建一个目录shell_tut 第4行：切换到shell_tut目录 第5行：循环条件，一共循环10次 第6行：创建一个test_1…10.txt文件 第7行：循环体结束","categories":[{"name":"2020年10月","slug":"2020年10月","permalink":"http://anqingliu.github.io/categories/2020年10月/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://anqingliu.github.io/tags/shell/"}]},{"title":"Spring Boot 2.0 依赖环境和项目结构介绍","slug":"J_SpringBoot2.0依赖环境和项目结构","date":"2020-09-10T11:40:58.852Z","updated":"2020-09-10T12:18:07.388Z","comments":true,"path":"2020/09/10/J_SpringBoot2.0依赖环境和项目结构/","link":"","permalink":"http://anqingliu.github.io/2020/09/10/J_SpringBoot2.0依赖环境和项目结构/","excerpt":"基础环境升级 JDK1.8 Maven IntelliJ IDEA 2018","text":"基础环境升级 JDK1.8 Maven IntelliJ IDEA 2018 项目结构介绍 pring Boot 的基础结构共三个文件，具体如下： src/main/java：程序开发以及主程序入口； src/main/resources：配置文件； src/test/java：测试程序。 123456789101112131415myproject +-src +- main +- java +-com.example.myproject +- comm +- model +- repository +- service +- web +- Application.java +- resources +- static +- templates +- application.properties +- test +-pom.xml com.example.myproject目录下： Application.java，建议放到根目录下面，是项目的启动类 comm 目录建议放置公共的类，如全局的配置文件工具类等； model 目录主要用于实体（Entity）与数据访问层（Repository）； repository 层主要是数据库访问层代码； service 层主要是业务类代码； web 层负责⻚页⾯面访问控制。 resources 目录下： static 目录存放 web 访问的静态资源，如 js、css、图片等； templates 目录存放页面模板； application.properties 存放项目的配置信息。 test 目录存放单元测试的代码； pom.xml 用于配置项目依赖包，以及其他配置。","categories":[{"name":"2020年9月","slug":"2020年9月","permalink":"http://anqingliu.github.io/categories/2020年9月/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://anqingliu.github.io/tags/SpringBoot/"}]},{"title":"Spring Boot 2.0 的更新","slug":"J_SpringBoot2.0更新","date":"2020-09-07T12:29:32.767Z","updated":"2020-09-10T11:40:09.802Z","comments":true,"path":"2020/09/07/J_SpringBoot2.0更新/","link":"","permalink":"http://anqingliu.github.io/2020/09/07/J_SpringBoot2.0更新/","excerpt":"基础环境升级 最低JDK8","text":"基础环境升级 最低JDK8 Spring Boot 2.0 基于 Spring Framework 5 构建，Spring Boot2.0更新 Jetty 开源的Servlet容器,例如JSP和Servlet Tomcat 8.5 Flyway5 数据库版本管理理工具. Hibernate5.2 Gradle3.4 Thymeleaf3.0 HikariCP HikariCP 是一个高性能的 JDBC 连接池 Security 包含ACLs、LDAP、JAAS、CAS OAuth 2 OAuth 2 是一个授权框架，或称授权标准，它可以使第三方应用程序或客户端获得对 HTTP 服务上（如Google、GitHub ）用户帐户信息的有限访问权限。 Micrometer 是一款监控指标的度量量类库，可以让你在没有供应商锁定的情况下对 JVM 的应⽤用程序代码进行调整。 Redis 默认使用Lettuce 配置属性绑定 转换器支持 Actuator 改进 测试 支持 HTTP/2 嵌入式 Netty服务器 Kotlin JOOQ 的支持 支持 Quartz 响应式编程 Spring Boot 2.0 支持了了动态 Gif 的启动 Logo 打印。 启动类 SpringBootServletInitializer Spring Boot 2.0 默认不不包含 log4j，建议使⽤用 slf4jThymeleaf 3.0 默认不不包含布局模块配置⽂文件 Thymeleaf 3.0 默认不不包含布局模块配置文件 配置文件,⼤大量量的 Servlet 专属的 server. 被移到了了 server.servlet. 下 WebMvcConfigurerAdapter 过期 Spring Boot JPA 变化,掉了了 xxxOne() 方法,delete() 方法和 findOne() 类似也被去掉了，可以使用 deleteById(Long id) 来替换，还有一个不同点是deleteById(Long id) 默认实现返回值为 void 需要指定主键的自增策略 分页组件 PageRequest 变化在 JPA 关联查询","categories":[{"name":"2020年9月","slug":"2020年9月","permalink":"http://anqingliu.github.io/categories/2020年9月/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://anqingliu.github.io/tags/SpringBoot/"}]},{"title":"Spring Boot 产生的背景和它的设计理理念","slug":"J_SpringBoot简介","date":"2020-09-07T12:04:58.084Z","updated":"2020-09-07T12:27:00.057Z","comments":true,"path":"2020/09/07/J_SpringBoot简介/","link":"","permalink":"http://anqingliu.github.io/2020/09/07/J_SpringBoot简介/","excerpt":"约定优于配置 本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。","text":"约定优于配置 本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。 我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置. 在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作简化。 Spring Boot Starters 基于约定优于配置的理理念来设计，Spring Boot Starter 中有两个核心组件：自动配置代码和提供自动配置模块及其它有用的依赖。 Spring、Spring Boot 和 Spring Cloud 的关系 Spring 最初核心的两大核心功能 Spring IoC 和 Spring Aop 成就了 Spring. Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利利性巧妙地简化了了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路路器器、数据监控等，都可以用 Spring Boot的开发风格做到一键启动和部署。 它们的关系`Spring IoC&gt;Spring&gt;SpringBoot&gt;SpringCloud 转载https://github.com/ityouknow/spring-boot-examples","categories":[{"name":"2020年9月","slug":"2020年9月","permalink":"http://anqingliu.github.io/categories/2020年9月/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://anqingliu.github.io/tags/SpringBoot/"}]},{"title":"java几道算法题","slug":"J_算法1","date":"2020-06-26T08:48:55.167Z","updated":"2020-06-26T09:14:50.705Z","comments":true,"path":"2020/06/26/J_算法1/","link":"","permalink":"http://anqingliu.github.io/2020/06/26/J_算法1/","excerpt":"题1 “百钱买百鸡”是我国古代的著名数学题。题目这样描述：3文钱可以买1只公鸡，2文钱可以买一只母鸡，1文钱可以买3只小鸡。用100 文钱买100 只鸡，那么各有公鸡、母鸡、小鸡多少只？","text":"题1 “百钱买百鸡”是我国古代的著名数学题。题目这样描述：3文钱可以买1只公鸡，2文钱可以买一只母鸡，1文钱可以买3只小鸡。用100 文钱买100 只鸡，那么各有公鸡、母鸡、小鸡多少只？ 123456789101112131415161718192021222324252627class ANS12&#123; public static void main(String[] args) &#123; //定义变量 //公鸡 int x=0; //母鸡 int y=0; //小鸡 int z=0; // for(x=0;x&lt;=33;x++)&#123;//表示的是公鸡的范围 for(y=0;y&lt;=50;y++)&#123;//表示的是母鸡的范围 //小鸡 z=100-x-y; //保证小鸡被3整除 if(z%3==0)&#123; //判断条件 if(3*x+2*y+(z/3)==100)&#123; System.out.println(\"公鸡：\"+x+\",母鸡：\"+y+\",小鸡：\"+z); &#125; &#125; &#125; &#125; &#125;&#125; 读入一个整数n，输出如下图形:当输入 n=3时，输出: * 当输入 n=4时，输出: * 1234567891011121314151617181920class ANS15&#123; public static void main(String[] args) &#123; // int n=5; //打印图形 for(int i=1;i&lt;=n;i++)&#123;//控制行数 //打印空格 for(int j=0;j&lt;n-i;j++)&#123; System.out.print(\" \"); &#125; //打印星星 for(int z=1;z&lt;=2*i-1;z++)&#123; System.out.print(\"*\"); &#125; //换行 System.out.println(); &#125; &#125;&#125;","categories":[{"name":"2020年6月","slug":"2020年6月","permalink":"http://anqingliu.github.io/categories/2020年6月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"Java中标识符定义的规则","slug":"J_标识符","date":"2020-06-25T06:32:09.461Z","updated":"2020-06-25T06:52:09.833Z","comments":true,"path":"2020/06/25/J_标识符/","link":"","permalink":"http://anqingliu.github.io/2020/06/25/J_标识符/","excerpt":"","text":"Java中标识符定义的规则 由大小写字母、数字、下划线、和美元符号组成，但不能以数字开头。标识符不能使用java中的关键字。 类和接口名。每个字的首字母大写，含有大小写zhi。例如，MyClass，HelloWorld，Time等。 方法名。dao首字符小写，其余的首字母大写，含大小写。尽量少用下划线。例如，myName，setTime等。这种命名方法叫做驼峰式命名。 常量名。基本数据类型的常量名使用全部大写字母，字与字之间用下划线分隔。对象常量可大小混写。例如，SIZE_NAME。 变量名。可大小写混写，首字符小写，字间分隔符用字的首字母大写。不用下划线，少用美元符号。给变量命名是尽量做到见名知义。-","categories":[{"name":"2020年6月","slug":"2020年6月","permalink":"http://anqingliu.github.io/categories/2020年6月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"java关键字","slug":"J_关键字","date":"2020-06-25T04:57:41.745Z","updated":"2020-06-25T06:37:34.374Z","comments":true,"path":"2020/06/25/J_关键字/","link":"","permalink":"http://anqingliu.github.io/2020/06/25/J_关键字/","excerpt":"java方法的返回 在java中被赋予了特殊含义的单词一共有53个、const和goto都是保留字、都是小写","text":"java方法的返回 在java中被赋予了特殊含义的单词一共有53个、const和goto都是保留字、都是小写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051关键字 含义abstract 表明类或者成员方法具有抽象属性assert 断言，用来进行程序调试boolean 基本数据类型之一，声明布尔类型的关键字break 提前跳出一个块byte 基本数据类型之一，字节类型case 用在switch语句之中，表示其中的一个分支catch 用在异常处理中，用来捕捉异常char 基本数据类型之一，字符类型class 声明一个类const 保留关键字，没有具体含义continue 回到一个块的开始处default 默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现do 用在do-while循环结构中double 基本数据类型之一，双精度浮点数类型else 用在条件语句中，表明当条件不成立时的分支enum 枚举extends 表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块float 基本数据类型之一，单精度浮点数类型for 一种循环结构的引导词goto 保留关键字，没有具体含义if 条件语句的引导词implements 表明一个类实现了给定的接口import 表明要访问指定的类或包instanceof 用来测试一个对象是否是指定类型的实例对象int 基本数据类型之一，整数类型interface 接口long 基本数据类型之一，长整数类型native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的new 用来创建新实例对象package 包private 一种访问控制方式：私用模式protected 一种访问控制方式：保护模式public 一种访问控制方式：共用模式return 从成员方法中返回数据short 基本数据类型之一,短整数类型static 表明具有静态属性strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范super 表明当前对象的父类型的引用或者父类型的构造方法switch 分支语句结构的引导词synchronized 表明一段代码需要同步执行this 指向当前实例对象的引用throw 抛出一个异常throws 声明在当前定义的成员方法中所有需要抛出的异常transient 声明不用序列化的成员域try 尝试一个可能抛出异常的程序块void 声明当前成员方法没有返回值volatile 表明两个或者多个变量必须同步地发生变化while 用在循环结构中;","categories":[{"name":"2020年6月","slug":"2020年6月","permalink":"http://anqingliu.github.io/categories/2020年6月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"安装python","slug":"P_安装python3.8版本","date":"2020-04-11T07:03:56.385Z","updated":"2020-04-11T07:20:49.809Z","comments":true,"path":"2020/04/11/P_安装python3.8版本/","link":"","permalink":"http://anqingliu.github.io/2020/04/11/P_安装python3.8版本/","excerpt":"前言:以前有用过python,但是很久没用了,电脑上自带python2.7和3.7版本,然后再次安装3.8的时候,就提示我有问题,于是,去网上找了下安装教程.记录一下","text":"前言:以前有用过python,但是很久没用了,电脑上自带python2.7和3.7版本,然后再次安装3.8的时候,就提示我有问题,于是,去网上找了下安装教程.记录一下 关于旧版本 在出问题后,我把旧版本全部卸掉了,这花费了我一个上午的时间,我本来以为我能修复的,结果没有成功,还是卸了省心,再重新安装一个新的 python3.8的安装包 这个安装包我本来想在官网上下载的,但是下载的网速实在受不了,太慢了,所以自己在国内网站上下载了一个. 题记 我的脑子一直比较混乱,反正这个也是写给我自己看得,我就吐槽下自己.想要学习,但是不知道学习什么,想要赚钱,但是也赚不了钱,一直处在能温饱的状态. 不会面对面沟通,会紧张,还是学习写代码吧,至少他是个可爱的东西. 开始正式安装 下面的东西,我是从别人的网上摘录下来的,经过我的亲身验证,保证可行,图片就弄了,国内访问github太卡了,我最近都从码云那边git代码了.对梯子没多大欲望,因为日常的可以满足. 版本,加入网速过关,可以去官网下载,下载32bit的,因为兼容性好. 安装步骤: 双击安装文件python-3.8.2-amd32.exe 勾选下方“Add Python 3.8 to PATH”，并选择“Customize installation”,为了不用自己去弄环境变量,原作者如是说 把Optional Features全部勾选上，点击“Next” Advanced Options勾选2/3/4项，然后选择安装路径，点击”Install“，等待安装完成 页面出现Successful字样，说明安装成功。 按win+R，输入”cmd“，回车，输入”python“，如果能如下正常回显，则成功 原文章链接地址","categories":[{"name":"2020年4月","slug":"2020年4月","permalink":"http://anqingliu.github.io/categories/2020年4月/"}],"tags":[{"name":"python","slug":"python","permalink":"http://anqingliu.github.io/tags/python/"}]},{"title":"springmvc回顾","slug":"J_springmvc回顾","date":"2020-03-16T01:21:27.426Z","updated":"2020-04-11T07:27:23.003Z","comments":true,"path":"2020/03/16/J_springmvc回顾/","link":"","permalink":"http://anqingliu.github.io/2020/03/16/J_springmvc回顾/","excerpt":"没弄好,里面代码忘了很多,弄个接近的springboot还失败了,伤心…","text":"没弄好,里面代码忘了很多,弄个接近的springboot还失败了,伤心… springmvc回顾 我现在码云上下载了源码和数据库数据,为什么不在github上下载呢,因为网速太慢,下了一般就跪了. 我先把代码复制到eclipse中,把数据库的数据放到数据库里. 把apache里的setting.xml镜像改成阿里云的地址,然后update项目里的资源,就可以打开网站了.我介绍下springmvc的大致流程 先配置apache,再新建一个maven项目 pom.xml报错web.xml is missing and &lt;failOnMissingWebXml&gt; is set to true问题,右击项目——&gt;Java EE Tools——&gt;Generate Deployment Descriptor Stub.然后系统会在src/main/webapp/WEB_INF文件加下创建web.xml文件。 新建一个db.properties,用于连接数据库 新建srping-aop.xml文件,spring-dap.xml文件,spring-mvc.xml文件,spring-service.xml文件 新建mappers,用于写数据库的sql语言 写bean,和那些spring联合 写mapper持久层 写service服务层 写Exception异常 写controller控制层 写登录控制器切片啥的,我现在也是迷迷糊糊的 把html改成jsp","categories":[{"name":"2020年3月","slug":"2020年3月","permalink":"http://anqingliu.github.io/categories/2020年3月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"反编译简单APK","slug":"J_反编译简单apk","date":"2019-12-07T07:17:14.922Z","updated":"2019-12-07T08:01:06.809Z","comments":true,"path":"2019/12/07/J_反编译简单apk/","link":"","permalink":"http://anqingliu.github.io/2019/12/07/J_反编译简单apk/","excerpt":"前言 反编译出来后,我还是没有把一个简单那的apk程序还原,正在探索中…","text":"前言 反编译出来后,我还是没有把一个简单那的apk程序还原,正在探索中… 准备必要工具 apktool 作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看 dex2jar 作用：将apk反编译成java源码（classes.dex转化成jar文件） jd-gui 作用：查看APK中classes.dex转化成出的jar文件，即源码文件 将【dex2jar-2.0.zip】和【jd-gui-windows-1.3.0.zip】分别解压 进入CMD命令行,来到apktool_2.0.1.jar目录下,运行java -jar jar包名.jar 使用如下的命令运行apktool_2.0.1.jar反编译java -jar apktool_2.0.1.jar d -f E:\\AndroidDevelopTool\\Android反编译工具包\\测试apk\\demo.apk -o demo 使用dex2jar反编译apk得到Java源代码 将要反编译的APK后缀名改为.rar或者 .zip，并解压，得到其中的classes.dex文件 将获取到的classes.dex放到之前解压出来的工具【dex2jar-2.0】文件夹内 在命令行下定位到dex2jar.bat所在目录，输入”d2j-dex2jar classes.dex 命令执行完成之后，在当前目录下就可以看到生成的Jar文件了 反编译classes.dex得到classes-dex2jar.jar文件之后，就可以使用【jd-gui】工具将class文件反编译成java源代码了 转载","categories":[{"name":"2019年12月","slug":"2019年12月","permalink":"http://anqingliu.github.io/categories/2019年12月/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://anqingliu.github.io/tags/Android/"}]},{"title":"Eclipse搭建SpringBoot之HelloWorld(转载)","slug":"J_SpringBoot的HelloWorld","date":"2019-10-29T14:38:22.294Z","updated":"2019-10-29T14:49:20.671Z","comments":true,"path":"2019/10/29/J_SpringBoot的HelloWorld/","link":"","permalink":"http://anqingliu.github.io/2019/10/29/J_SpringBoot的HelloWorld/","excerpt":"HelloWorld 首先新建Maven工程","text":"HelloWorld 首先新建Maven工程 勾选第一个按钮，第三个是选择working set ，你可以不选 下一步，配置工程信息，注意打包为jar 打开pom.xml文件，添加spring-boot依赖 123456789101112131415161718192021222324&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 新建文件src/main/hello/HelloController.java 12345678910111213package hello;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/\") public String hello()&#123; return \"Greetings from Spring Boot!\"; &#125;&#125; 新建src/main/hello/Application.java 1234567891011121314package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; // http://localhost:8080/ SpringApplication.run(Application.class, args); &#125;&#125; 运行Application 访问localhost:8080/-原文有图","categories":[{"name":"2019年10月","slug":"2019年10月","permalink":"http://anqingliu.github.io/categories/2019年10月/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://anqingliu.github.io/tags/SpringBoot/"}]},{"title":"Spring Boot 问题集001","slug":"J_SpringBootProblem001","date":"2019-10-28T13:51:01.465Z","updated":"2019-10-28T14:05:15.395Z","comments":true,"path":"2019/10/28/J_SpringBootProblem001/","link":"","permalink":"http://anqingliu.github.io/2019/10/28/J_SpringBootProblem001/","excerpt":"新建Maven项目时，每个pom文件第一行都报错 java报错 pom.xml第一行报”org.apache.maven.archiver.MavenArchiver.getManifest(org.apache.maven.project…(转载)","text":"新建Maven项目时，每个pom文件第一行都报错 java报错 pom.xml第一行报”org.apache.maven.archiver.MavenArchiver.getManifest(org.apache.maven.project…(转载) 问题分析 原因就是你的maven的配置文件不是最新的 解决方案 更新eclipse中的maven插件 Help——&gt;Install New SoftWare 点击 Add,添加配置信息 name为 MavenArchiver Location中输入 http://repo1.maven.org/maven2/.m2e/connectors/m2eclipse-mavenarchiver/0.17.2/N/LATEST/ 点击 next 前，将 eclipse Install 窗口右下角的 Contact all update sites during install to find required software 选项取消掉。 一直next confirm 安装更新 提示重启eclipse 然后再右键项目maven update project 原文","categories":[{"name":"2019年10月","slug":"2019年10月","permalink":"http://anqingliu.github.io/categories/2019年10月/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://anqingliu.github.io/tags/SpringBoot/"}]},{"title":"springmvc和springboot的区别","slug":"J_springmvc和springboot的区别","date":"2019-10-27T10:58:01.265Z","updated":"2019-10-27T11:30:28.436Z","comments":true,"path":"2019/10/27/J_springmvc和springboot的区别/","link":"","permalink":"http://anqingliu.github.io/2019/10/27/J_springmvc和springboot的区别/","excerpt":"介绍 Spring 是一个“引擎”； Spring MVC 是基于Spring的一个 MVC 框架 ； Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。","text":"介绍 Spring 是一个“引擎”； Spring MVC 是基于Spring的一个 MVC 框架 ； Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。 前言 我以前学过Spring MVC,不过那些配置都是Copy过来的,反正都不知道那些配置是做什么的(忘的差不多了),还不如直接用Spring Boot(下面文章是转载来的) Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。 说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。 Spring MVC的功能 Spring MVC提供了一种轻度耦合的方式来开发web应用。 Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。 Spring Boot的功能 Spring Boot实现了自动配置，降低了项目搭建的复杂度。 众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。 对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。 引用","categories":[{"name":"2019年10月","slug":"2019年10月","permalink":"http://anqingliu.github.io/categories/2019年10月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"java基础","slug":"J_javaDemo","date":"2019-05-03T16:09:30.735Z","updated":"2019-05-03T16:12:05.664Z","comments":true,"path":"2019/05/04/J_javaDemo/","link":"","permalink":"http://anqingliu.github.io/2019/05/04/J_javaDemo/","excerpt":"java方法的返回","text":"java方法的返回 12345678910111213141516171819202122232425public class Demo &#123; public static void main(String[] args) &#123; int a = 1; String b = \"abc\"; Point p = new Point(1,2); Collection c = new ArrayList(); c.add(p); dosome(a,b,p,c); System.out.println(\"a:\"+a); System.out.println(\"b:\"+b); System.out.println(\"p:\"+p); System.out.println(\"c:\"+c); &#125; public static void dosome(int a,String b,Point p,Collection c)&#123; a = a + 1; b = b + \"!\"; p.setX(2); p = new Point(3,4); c.clear(); c.add(p); c = new ArrayList(); c.add(new Point(5,6)); &#125;&#125; 重写Point方法12345678910111213141516171819202122232425262728293031323334353637public class Point &#123; private int x; private int y; public Point(int x, int y) &#123; super(); this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public String toString() &#123; return \"(\"+x+\",\"+y+\")\"; &#125; public boolean equals(Object o)&#123; if(o==null)&#123; return false; &#125; if(o==this)&#123; return true; &#125; if(o instanceof Point)&#123; Point p = (Point)o; return p.x==this.x&amp;&amp;p.y==this.y; &#125; return false; &#125;&#125; 输出1234a:1b:abcp:(2,2)c:[(3,4)]","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"简易聊天室","slug":"J_聊天室","date":"2019-05-03T15:23:33.012Z","updated":"2019-05-03T15:45:33.551Z","comments":true,"path":"2019/05/03/J_聊天室/","link":"","permalink":"http://anqingliu.github.io/2019/05/03/J_聊天室/","excerpt":"聊天室服务端","text":"聊天室服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class Server &#123; /* * 运行在服务端的ServerSocket * 有两个主要作用: * 1:向系统申请对外的服务端口,客户端就是通过 * 这个端口与服务端建立连接的. * 2:监听服务端口,等待客户端连接.一旦一个客户端 * 通过Socket与服务端建立连接,那么ServerSocket * 会创建一个Socket与该客户端通讯. */ private ServerSocket server; /* * 该数组用于存放所有客户端的输出流 */// private PrintWriter[] allOut = new PrintWriter[0]; private List&lt;PrintWriter&gt; allOut = new ArrayList&lt;PrintWriter&gt;(); public Server()&#123; try &#123; /* * 创建ServerSocket的同时向系统申请 * 对外的服务端口.注意,该端口不能和 * 其他程序冲突,否则会抛出地址被占用 * 的异常. */ server = new ServerSocket(8088); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void start()&#123; try &#123; /* * ServerSocket提供方法: * Socket accept() * 该方法是一个阻塞方法,调用后即等待 * 客户端的连接,一旦一个客户端通过 * 端口连接,那么accept方法会返回一个 * Socket实例,通过这个Socket实例就 * 可以与刚连接的客户端交互了 */ while(true)&#123; System.out.println(\"等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"一个客户端连接了!\"); //启动一个线程,处理该客户端交互工作 ClientHandler handler = new ClientHandler(socket); Thread t = new Thread(handler); t.start(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Server server = new Server(); server.start(); &#125; /** * 该线程任务负责与指定Socket所对应的客户端 * 进行交互. * @author adminitartor * */ private class ClientHandler implements Runnable&#123; //当前线程通过这个Socket与对应客户端交互 private Socket socket; /** * 实例化时将对应客户端的Socket传入 * @param socket */ public ClientHandler(Socket socket)&#123; this.socket = socket; &#125; public void run()&#123; PrintWriter pw = null; try &#123; InputStream in = socket.getInputStream(); BufferedReader br = new BufferedReader( new InputStreamReader( in,\"UTF-8\" ) ); /* * 获取输出流,用于给当前客户端回复消息 */ pw = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream(), \"UTF-8\" ) ),true ); //将当前客户端对应的输出流存入共享数组 synchronized (allOut) &#123; // //1扩容数组// allOut = Arrays.copyOf(allOut, allOut.length+1);// //2将输出流存入数组// allOut[allOut.length-1] = pw; allOut.add(pw); &#125; /* * 客户端在断开连接时不同系统有不同反应 * linux的客户端断开后,br.readLine方法会 * 返回null. * windows的客户端断开连接后,br.readLine方法 * 会直接抛出异常. */ String message = null; while((message = br.readLine())!=null)&#123; System.out.println(\"客户端说:\"+message); //回复客户端// pw.println(\"客户端说:\"+message); //发送给所有客户端 synchronized (allOut) &#123;// for(int i=0;i&lt;allOut.length;i++)&#123;// allOut[i].println(\"客户端说:\"+message);// &#125; for(PrintWriter o : allOut)&#123; o.println(\"客户端说:\"+message); &#125; &#125; &#125; &#125; catch (Exception e) &#123; &#125; finally&#123; //处理客户端断开连接后的操作 //1将该客户端的输出流从共享数组中删除 synchronized (allOut) &#123;// for(int i=0;i&lt;allOut.length;i++)&#123;// if(allOut[i]==pw)&#123;// //将最后一个元素放入当前位置// allOut[i] = allOut[allOut.length-1];// //缩容// allOut = Arrays.copyOf(allOut, allOut.length-1);// break;// &#125;// &#125; allOut.remove(pw); &#125; /* * 2客户端断开连接后,服务端关闭 * 该客户端Socket,释放资源 */ try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 聊天室客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class Client &#123; /* * java.net.Socket * 套接字,封装了TCP协议.Socket提供了两条流 * 用来与服务端进行双向通讯. */ private Socket socket; /** * 构造方法,用来初始化客户端 */ public Client()&#123; try &#123; /* * 实例化Socket就是连接服务端的过程 * 参数1:服务端地址 * 参数2:服务端开启的服务端口 * * 通过服务端IP地址可以找到服务端所处 * 计算机,再通过端口找到运行在服务端 * 计算机上的服务端应用程序. */ socket = new Socket(\"localhost\",8088); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 客户端开始工作的方法 */ public void start()&#123; try &#123; //先启动线程接收服务端发送的消息 ServerHandler handler = new ServerHandler(); Thread t = new Thread(handler); t.start(); Scanner scanner = new Scanner(System.in); /* * Socket提供方法: * OutputStream getOutputStream() * 通过返回的字节输出流写出的数据会发送 * 给远端计算机,对于客户端这边而言远端 * 计算机就是服务端了. */ OutputStream out = socket.getOutputStream(); PrintWriter pw = new PrintWriter( new BufferedWriter( new OutputStreamWriter( out,\"UTF-8\" ) ),true ); while(true)&#123; String line = scanner.nextLine(); pw.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.start(); &#125; /** * 该线程负责循环接收服务端发送过来的消息. * 给服务端发送消息与接收服务端发过来的消息 * 要放在两个不同的线程要运行,这样才能做到 * 互相不干扰. * @author adminitartor * */ private class ServerHandler implements Runnable&#123; public void run()&#123; try &#123; BufferedReader br = new BufferedReader( new InputStreamReader( socket.getInputStream(), \"UTF-8\" ) ); String message = null; while((message = br.readLine())!=null)&#123; System.out.println(message); &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125;","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Demo","slug":"Demo","permalink":"http://anqingliu.github.io/tags/Demo/"}]},{"title":"IO流","slug":"J_IO流","date":"2019-05-01T14:58:27.833Z","updated":"2019-05-01T16:07:33.529Z","comments":true,"path":"2019/05/01/J_IO流/","link":"","permalink":"http://anqingliu.github.io/2019/05/01/J_IO流/","excerpt":"IO流 java提供了标准的IO操作,即:输入与输出","text":"IO流 java提供了标准的IO操作,即:输入与输出 IO的作用是可以让我们的程序与外界进行数据交换.比如从网络读写数据,读取键盘数据,读写文件数据等等. 标准的IO根据将功能按照方向划分 输入:从外界到程序中的过程,这是”读”的过程 输出:从程序发送至外界的过程,这是”写”的过程 学习IO的重点:理解流链接操作,通过应用流连接,按照需求组合高级流与低级流,完成读写操作. 流分为:节点流(低级流),处理流(高级流) 节点流:实际链接程序与另一端的管道,负责在两端之间传送数据.注意:读写一定是建立在节点流的基础上进行的. 处理流:不能独立存在,可以链接在其他流上,处理流自带某种对数据的加工操作,所以数据流经该流会对这些数据进行处理,这样可以简化我们对数据的处理操作. java.io.InputStream 所有字节输入流的父类,是一个抽象类,规定了所有字节输入流都必须具备的读取字节的方法 java.io.OutputStream 所有字节输出流的父类,是一个抽象类,规定了所有字节输出流都必须具备的写出字节的方法 文件流 文件流是一套低级流,作用是读写文件数据. 文件输出流支持的两种写模式: 覆盖写操作,即:若写出的文件有数据,则将原有数据全部删除,将本次通过流写出的内容作为文件数据.FileOutputStream(String path), FileOutputStream(File file) 追加写操作,若文件有数据则全部保留,从该文件末尾追加内容FileOutputStream(String path,boolean append)FileOutputStream(File file,boolean append) 文件流与RandomAccessFile的对比: 1:论功能是一致的,都是用来读写文件数据 2:RAF对于文件即可读也可写,但是文件流不行,文件输入流只用来读文件数据,文件输出流用来向文件中写入数据 流的特点是顺序读写操作,即:读写是不能回退的.RAF是随机读写操作,因为依靠指针位置进行读写,所以可以通过操作指针对文件任意位置随意读写.","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"流的注册和读取","slug":"J_流的注册和读取","date":"2019-05-01T07:51:06.257Z","updated":"2019-05-03T15:28:10.970Z","comments":true,"path":"2019/05/01/J_流的注册和读取/","link":"","permalink":"http://anqingliu.github.io/2019/05/01/J_流的注册和读取/","excerpt":"完成用户注册功能 用user.dat文件保存用户信息 每个用户的信息包括:用户名,密码,昵称,年龄 其中年龄是int值,其余都是字符串.","text":"完成用户注册功能 用user.dat文件保存用户信息 每个用户的信息包括:用户名,密码,昵称,年龄 其中年龄是int值,其余都是字符串. 1234567891011121314151617181920212223242526272829303132333435public class Test1 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(\"user.dat\",\"rw\"); //先将指针移动到文件末尾,以便追加新记录 raf.seek(raf.length()); String name = \"测试\"; String password = \"123456\"; String nickname = \"测\"; int age = 18; /* * 每条记录占用100字节,其中用户名,密码, * 昵称各占32字节,int型的age占4字节. * 数据\"留白\"的目的是便于后期修改信息. */ //写用户名 byte[] data = name.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data);//一次写了32字节 data = password.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data); data = nickname.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data); raf.writeInt(age); System.out.println(\"注册完毕!\"); raf.close(); &#125;&#125; 将每个用户信息输出123456789101112131415161718192021222324public class Test2 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(\"user.dat\",\"r\"); /* * 将每个用户信息输出格式:user,pwd,nick,age */ for(int i=0;i&lt;raf.length()/100;i++)&#123; //读用户名 byte[] data = new byte[32]; raf.read(data); String name = new String(data,\"UTF-8\").trim(); //读密码 raf.read(data); String pwd = new String(data,\"UTF-8\").trim(); //读昵称 raf.read(data); String nickname = new String(data,\"UTF-8\").trim(); //读年龄 int age = raf.readInt(); System.out.println(name+\",\"+pwd+\",\"+nickname+\",\"+age); &#125; &#125;&#125;","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"鼠标移动自动闪开","slug":"H_鼠标移动自动闪开","date":"2019-04-29T15:13:31.399Z","updated":"2019-04-29T15:21:04.657Z","comments":true,"path":"2019/04/29/H_鼠标移动自动闪开/","link":"","permalink":"http://anqingliu.github.io/2019/04/29/H_鼠标移动自动闪开/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;body&gt; &lt;canvas id=\"pane\" width=\"1024\" height=\"520\"&gt;&lt;/canvas&gt; &lt;script&gt; var no = new Image(); no.src = \"images/no.png\"; var canvas = document.getElementById('pane'); var ctx = canvas.getContext('2d'); var btnN = new Btn(564,402,686,294,no); setInterval(function()&#123; btnN.paintBtn(); &#125;); canvas.onmousemove = function(evt)&#123; var e = evt||event; if(btnN.contains(e.x+331, e.y+138))&#123;//鼠标靠近图片x331,y138的地方 btnN.x = Math.floor((Math.random() * 190) + 648); btnN.y = Math.floor((Math.random() * 190) + 210); &#125; &#125;; function Btn(pointx,pointy,x,y,say)&#123; this.x=x; this.y=y; this.pointx=pointx; this.pointy=pointy; this.paintBtn=function()&#123; ctx.save();//保存当前画布状态 ctx.translate(this.x, this.y);//函数用于在二维空间中移动一个元素。 var a = Math.atan((this.y- this.pointy)/(this.x - this.pointx)); a=a&lt;0?a+Math.PI:a; ctx.rotate(a);//旋转 ctx.restore();//恢复最近一近的画布保存状态 ctx.drawImage(say,this.x-say.naturalWidth/2,this.y-say.naturalHeight/2); &#125;; this.contains = function(ex,ey)&#123; return Math.sqrt(Math.pow((ex-this.x),2)+Math.pow((ey-this.y),2))&lt;50; &#125;; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]},{"title":"猜数字小游戏","slug":"J_java猜数字游戏","date":"2019-04-27T14:06:25.950Z","updated":"2019-04-27T14:16:24.106Z","comments":true,"path":"2019/04/27/J_java猜数字游戏/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/J_java猜数字游戏/","excerpt":"介绍 随机生成一个数字,然后开始猜的一个游戏","text":"介绍 随机生成一个数字,然后开始猜的一个游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;public class Guessing &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); char[] chs = generate(); //获取随机字符数组 //System.out.println(chs); //作弊 int count = 0; //猜错的次数 while(true)&#123; //自造死循环 System.out.println(\"猜吧!\"); String str = scan.nextLine().toUpperCase(); //接收用户输入的字符串并转换为大写字母 if(str.equals(\"EXIT\")) &#123; //判断字符串内容是否是EXIT System.out.println(\"下次再来吧!\"); break; &#125; char[] input = str.toCharArray(); //将字符串转换为字符数组 int[] result = check(chs,input); //对比:随机字符数组与用户输入的字符数组 if(result[0]==chs.length) &#123; int score = 100*chs.length-10*count; //1个字符100分，猜错一次扣10分 System.out.println(\"恭喜你猜对了，得分为:\"+score); break; &#125;else &#123; count++; System.out.println(\"字符对个数为:\"+result[1]+\"，位置对个数为:\"+result[0]); &#125; &#125; &#125; //生成随机字符数组chs public static char[] generate() &#123; char[] chs = new char[5]; //随机字符数组 char[] letters = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; //随机字符范围数组 boolean[] flags = new boolean[letters.length]; //标记数组 for(int i=0;i&lt;chs.length;i++) &#123; //遍历随机字符数组 int index; do &#123; index = (int)(Math.random()*letters.length); //随机下标(0到25之间) &#125;while(flags[index]==true); //下标index对应的标记为true，表示对应字符已经使用过，则重新生成index下标 chs[i] = letters[index]; //基于下标index获取对应的字符并赋值给chs中的每一个元素 flags[index] = true; //将下标index对应的标记修改为true，表示对应字符已存过 &#125; return chs; &#125; //对比:随机字符数组chs与用户输入的字符数组input public static int[] check(char[] chs,char[] input) &#123; int[] result = new int[2]; //对比结果(0,0)--假设result[1]为字符对，result[0]为位置对 for(int i=0;i&lt;chs.length;i++) &#123; //遍历随机字符数组 for(int j=0;j&lt;input.length;j++) &#123; //遍历用户输入的字符数组 if(chs[i]==input[j]) &#123; //字符对 result[1]++; //字符对个数增1 if(i==j) &#123; //位置对 result[0]++; //位置对个数增1 &#125; break; //剩余input元素不再参与比较了 &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://anqingliu.github.io/tags/游戏/"}]},{"title":"java基本数据类型","slug":"J_java基本数据类型","date":"2019-04-27T11:32:23.029Z","updated":"2019-04-27T13:55:27.635Z","comments":true,"path":"2019/04/27/J_java基本数据类型/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/J_java基本数据类型/","excerpt":"基本数据类型","text":"基本数据类型 int:整形,4个字节 整数直接量默认为int类型，但不能超范围，超范围则编译错误 两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入) 整数运算时若超出范围会发生溢出，溢出是需要避免的 long:长整型，8个字节 长整型的直接量，需在数字后加L或l 运算时若有可能溢出，建议在第1个数字后加L System.currentTimeMillis()用于获取自1970.1.1零时到此时此刻的毫秒数 double:浮点型，8个字节(精确运算场合不能用double) 浮点数直接量默认为double型，若想表示float需在数字后加F或f double和float型数据参与运算时，有可能会出现舍入误差 boolean:布尔型，1个字节 只能取值为true或false char:字符型，2个字节 采用Unicode字符集编码，每个字符对应一个码,表现的形式是字符char，但本质上是码int(0到65535之间),&#39;a&#39;=97 &#39;A&#39;=65 &#39;0&#39;=48 字符型直接量必须放在单引号中，只能有一个 特殊符号需要通过\\来转义 财务ERP—————–BigDecimal 基本数据类型间的转换: 数据类型从小到大依次为:byte-short-int(char)-long-float-double 自动类型转换:小类型到大类型 强制类型转换:大类型到小类型 语法: (要转换成为的数据类型)变量,强转有可能会发生溢出或精度的丢失 整数直接量可以直接赋值给byte、short、char，但不能超出范围 byte、short、char型数据参与运算时，先一律转换为int再运算 命名 只能包含字母、数字、_和$符，并且不能以数字开头 严格区分大小写 不能使用关键字 可以中文命名，但不建议,建议”英文的见名知意”、”驼峰命名法” 例子 int的最大值和最小值的变换 12int balance = 2147483647;balance = balance+1; //-2147483648(最小值)","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"java基础","slug":"J_java介绍","date":"2019-04-27T08:14:47.338Z","updated":"2020-06-25T06:08:13.047Z","comments":true,"path":"2019/04/27/J_java介绍/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/J_java介绍/","excerpt":"Java开发环境 编译运行过程 编译期:.java源文件,经过编译,生成.class字节码文件 运行期: JVM加载.class并运行.class .java文件–通过javac命令—编译—.class文件 .class文件—通过java命令–运行–结果","text":"Java开发环境 编译运行过程 编译期:.java源文件,经过编译,生成.class字节码文件 运行期: JVM加载.class并运行.class .java文件–通过javac命令—编译—.class文件 .class文件—通过java命令–运行–结果 特点:跨平台,一次编程到处使用(显示中一般需要重新编写) JVM:java虚拟机,加载.class并运行.class 事先在对应的操作系统上安装对应版本的JVM，java 程序是在JVM中进行执行，使得不同的操作系统只要是同一java程序的得到的结果是一样的 JRE:java运行环境(Java Runtime Environment)除了包含JVM以外还包含了运行java程序所必须的环境 JVM+java系统类库(API) JDK:java开发工具包(java Devlopment Kit),除了包含JRE以外还包含了开发java程序所必须的命令工具 JDK=JRE+编译,运行等命令工具 运行java程序的最小环境是JRE 开发java程序的最小环境是JDK ####配置环境变量 JVAV_HOME:指向jdk的安装路径 CLASSPATH:表示类的搜索路径 PATH:指向jdk下的bin目录 ####注意事项 .class文件名和类名保持一致 公共类的类名要和.java文件名保持一致 一个.java文件可以支持多个类，但是最多只能有一个公共类(public class) .java文件可以创建过个类，有几个类就能编译生产几个.class文件，如果.java文件中的类名出现大小写最后的结果就是最后一个类的内容","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"svn的搭建和使用","slug":"Z_离线服务器搭建svn并使用","date":"2019-04-21T10:19:16.932Z","updated":"2019-04-27T03:21:30.990Z","comments":true,"path":"2019/04/21/Z_离线服务器搭建svn并使用/","link":"","permalink":"http://anqingliu.github.io/2019/04/21/Z_离线服务器搭建svn并使用/","excerpt":"因为公司使用的是内网，所以只能用下载安装包的办法来搭建 一、需要下载的安装包 subversion-1.11.1.tar.gz sqlite-autoconf-3280000.tar.gz apr-1.7.0.tar.gz apr-util-1.6.1.tar.gz zlib 1.2.11.tar.xz 当安装apr-util出错时，需要安装expat_2.0.1.orig.tar.gz","text":"因为公司使用的是内网，所以只能用下载安装包的办法来搭建 一、需要下载的安装包 subversion-1.11.1.tar.gz sqlite-autoconf-3280000.tar.gz apr-1.7.0.tar.gz apr-util-1.6.1.tar.gz zlib 1.2.11.tar.xz 当安装apr-util出错时，需要安装expat_2.0.1.orig.tar.gz 二、解压当前包 tar -tar -xzvf 需要解压的包 在home下新建svn文件夹 三、开始安装 安装apr cd apr-1.7.0 ./configure prefix=/home/svn/apr-1.7.0 make make install 安装 apr-uill cd apr-util-1.6.1 ./configure prefix=/home/svn/apr-util-1.6.1 --with-apr=/home/svn/apr-1.7.0 make make install 当apr-util出错时 cd expat-2.0.1 ./configure make make install 重新安装apr-util 安装zlib cd zlib-1.2.11 ./configure prefix=/home/svn/zlib-1.2.11 make make install 安装sqllite mv sqlite-autoconf-3280000 ./subversion-1.9.7/sqlite-amalgamation 安装subversion cd subversion-1.11.1 ./configure prefix=/home/svn/subversion-1.11.1 --with-apr=/home/svn/apr-1.7.0 --with-apr-util=/home/svn/apr-util-1.6.1 --with-zlib=/home/svn/zlib make make install 四、将svn加入path，并验证安装是否成功 cd vim .bash_profile :i PATH=/home/svn/subversion-1.11.1/bin:$PATH 保存退出 . .bash_profile 在ect/bash_profile里也加一下path . profile 验证 svnserve --version 出现版本号即验证成功 五、配置仓库 mkdir -p myproject svnadmin create /home/svn/myproject 修改配置文件 cd myproject/conf vim subversion.conf 将以下几项前的#删除，并顶格编写 anon-access = none # 使非授权用户无法访问 auth-access = write # 使授权用户有写权限 password-db = /opt/svndata/repos/conf/passwd # 指明密码文件路径 authz-db = /opt/svndata/repos/conf/authz # 访问控制文件 realm = /opt/svndata/repos # 认证命名空间，subversion会在认证提示里显示，并且作为凭证缓存的关键字. 保存并退出 vim passwd 输入以下内容： admin = admin username2 = password2 可以添加多个，此为用户名密码对。保存并退出 vim authz &lt;用户组名&gt; = &lt;用户1&gt;,&lt;用户2&gt;, 其中，1个用户组可以包含1个或多个用户，用户间以逗号分隔。 别忘了[/]和* = rw 保存退出 六、启动服务 svnserve -d 版本库路径 --listen 端口号 -r /home/svn/myproject 例如svnserve -d --listen-port 3690 -r /home/svn/myproject 启动后，可在进程中查找是否已启动svn服务ps - ef|grep svn 七、开通端口，开通防火墙端口 这步我没操作，不过看网上的大大有写，具体可以看大大们的 八、访问服务 安装TortoiseSVN.msi,新建一个文件夹，右键，选择svn检测，输入svn://SVN服务器的IP地址,点击确定，弹出一个框，输入账号密码，账号密码是第五步设置的那几个 把你团队需要的东西放进新建的文件夹，add后commit就行了 九、最后感言 安装不易，且安且珍惜","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://anqingliu.github.io/tags/软件/"}]},{"title":"博客搭建过程","slug":"H_博客搭建过程","date":"2019-04-07T13:48:08.413Z","updated":"2019-10-27T11:30:44.959Z","comments":true,"path":"2019/04/07/H_博客搭建过程/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/H_博客搭建过程/","excerpt":"在假期搭建了博客，功能还在完善，但基本可以使用 首先： 我先去bilibili学习了一下搭建博客的视频 跟着视频就能做出一个成功的范例，-。-","text":"在假期搭建了博客，功能还在完善，但基本可以使用 首先： 我先去bilibili学习了一下搭建博客的视频 跟着视频就能做出一个成功的范例，-。- 然后： 想着把内容记下来，然后去找了一下相关的教程，重新做了一遍 我是用window 7安装的hexo，用系统自带的cmd，先去hexo官网下载hexo安装包 用淘宝镜像源$ npm install -g cnpm --registry=https://registry.npm.taobao.org，不仅因为速度的原因，在后面的操作中，用npm下载失败而用cnpm下载成功 $ cnpm install -g hexo-cli安装hexo 进入放置Blog的一个空白的文件夹，hexo init初始化博客 hexo s启动博客，打开浏览器，输入http://localhost:4000就可以打开你的博客了 进入source\\_posts,新建一个md文件，就是第一篇博客 然后hexo g生成静态文件 接着： 新建一个 github的账号，新建一个和你账号名一样的仓库，以我为例anqingliu.github.io 然后下载一个插件cnpm install hexo-deployer-git --save 打开hexo文件里的_config.yml 写上你自己博客的地址，如果第一次上传，需要你的账号和密码 123type: gitrepo: git@github.com:Anqingliu/Anqingliu.github.io.gitbranch: master 用hexo d上送你的博客 最后： 选一个你喜欢的主题，用git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 修改你的_config.yml文件为theme: material-x hexo clean先清除一下原有格式化 hexo g重新生成 hexo d上送到github","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]},{"title":"测试发文","slug":"H_Test","date":"2019-04-07T13:34:33.646Z","updated":"2019-04-27T03:19:35.045Z","comments":true,"path":"2019/04/07/H_Test/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/H_Test/","excerpt":"测试发文","text":"测试发文 你好，安晴！","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://anqingliu.github.io/tags/测试/"}]},{"title":"Hexo的简介和使用","slug":"H_hello-world","date":"2019-04-07T04:18:59.652Z","updated":"2019-04-27T03:21:38.021Z","comments":true,"path":"2019/04/07/H_hello-world/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/H_hello-world/","excerpt":"注：这个博客使用了hexo搭建 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"注：这个博客使用了hexo搭建 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]}]}