{"meta":{"title":"AnQing","subtitle":"AnQing Blog","description":null,"author":null,"url":"http://anqingliu.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-04-25T12:09:09.270Z","updated":"2019-04-25T12:09:09.270Z","comments":true,"path":"404.html","permalink":"http://anqingliu.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"一些必要的链接","date":"2019-04-27T08:06:44.911Z","updated":"2019-04-27T08:06:44.911Z","comments":true,"path":"friends/index.html","permalink":"http://anqingliu.github.io/friends/index.html","excerpt":"","text":"Anqingliu material-x博客主题"},{"title":"404 Not Found","date":"2019-04-25T13:01:46.136Z","updated":"2019-04-25T13:01:46.136Z","comments":true,"path":"about/index.html","permalink":"http://anqingliu.github.io/about/index.html","excerpt":"","text":"关于我 一个安静的人待完善中…"},{"title":"","date":"2019-04-25T12:07:07.913Z","updated":"2019-04-25T12:07:07.913Z","comments":true,"path":"mylist/index.html","permalink":"http://anqingliu.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-04-25T12:06:20.535Z","updated":"2019-04-25T12:06:20.535Z","comments":true,"path":"tags/index.html","permalink":"http://anqingliu.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2019-04-25T13:02:27.224Z","updated":"2019-04-25T13:02:27.224Z","comments":true,"path":"projects/index.html","permalink":"http://anqingliu.github.io/projects/index.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"springmvc和springboot的区别","slug":"springmvc和springboot的区别","date":"2019-10-27T10:58:01.265Z","updated":"2019-10-27T11:30:28.436Z","comments":true,"path":"2019/10/27/springmvc和springboot的区别/","link":"","permalink":"http://anqingliu.github.io/2019/10/27/springmvc和springboot的区别/","excerpt":"介绍 Spring 是一个“引擎”； Spring MVC 是基于Spring的一个 MVC 框架 ； Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。","text":"介绍 Spring 是一个“引擎”； Spring MVC 是基于Spring的一个 MVC 框架 ； Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。 前言 我以前学过Spring MVC,不过那些配置都是Copy过来的,反正都不知道那些配置是做什么的(忘的差不多了),还不如直接用Spring Boot(下面文章是转载来的) Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring 的 ioc和 aop ioc 提供了依赖注入的容器 aop ，解决了面向横切面的编程，然后在此两者的基础上实现了其他延伸产品的高级功能。Spring MVC是基于 Servlet 的一个 MVC 框架 主要解决 WEB 开发的问题，因为 Spring 的配置非常复杂，各种XML、 JavaConfig、hin处理起来比较繁琐。于是为了简化开发者的使用，从而创造性地推出了Spring boot，约定优于配置，简化了spring的配置流程。 说得更简便一些：Spring 最初利用“工厂模式”（DI）和“代理模式”（AOP）解耦应用组件。大家觉得挺好用，于是按照这种模式搞了一个 MVC框架（一些用Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。然后有发现每次开发都写很多样板代码，为了简化工作流程，于是开发出了一些“懒人整合包”（starter），这套就是 Spring Boot。 Spring MVC的功能 Spring MVC提供了一种轻度耦合的方式来开发web应用。 Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。 Spring Boot的功能 Spring Boot实现了自动配置，降低了项目搭建的复杂度。 众所周知Spring框架需要进行大量的配置，Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 Spring Boot只是承载者，辅助你简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和你上面描述的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。 对使用者来说，换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。 引用","categories":[{"name":"2019年10月","slug":"2019年10月","permalink":"http://anqingliu.github.io/categories/2019年10月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"java基础","slug":"java基础2","date":"2019-05-03T16:09:30.735Z","updated":"2019-05-03T16:12:05.664Z","comments":true,"path":"2019/05/04/java基础2/","link":"","permalink":"http://anqingliu.github.io/2019/05/04/java基础2/","excerpt":"java方法的返回","text":"java方法的返回 12345678910111213141516171819202122232425public class Demo &#123; public static void main(String[] args) &#123; int a = 1; String b = \"abc\"; Point p = new Point(1,2); Collection c = new ArrayList(); c.add(p); dosome(a,b,p,c); System.out.println(\"a:\"+a); System.out.println(\"b:\"+b); System.out.println(\"p:\"+p); System.out.println(\"c:\"+c); &#125; public static void dosome(int a,String b,Point p,Collection c)&#123; a = a + 1; b = b + \"!\"; p.setX(2); p = new Point(3,4); c.clear(); c.add(p); c = new ArrayList(); c.add(new Point(5,6)); &#125;&#125; 重写Point方法12345678910111213141516171819202122232425262728293031323334353637public class Point &#123; private int x; private int y; public Point(int x, int y) &#123; super(); this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public String toString() &#123; return \"(\"+x+\",\"+y+\")\"; &#125; public boolean equals(Object o)&#123; if(o==null)&#123; return false; &#125; if(o==this)&#123; return true; &#125; if(o instanceof Point)&#123; Point p = (Point)o; return p.x==this.x&amp;&amp;p.y==this.y; &#125; return false; &#125;&#125; 输出1234a:1b:abcp:(2,2)c:[(3,4)]","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"简易聊天室","slug":"聊天室","date":"2019-05-03T15:23:33.012Z","updated":"2019-05-03T15:45:33.551Z","comments":true,"path":"2019/05/03/聊天室/","link":"","permalink":"http://anqingliu.github.io/2019/05/03/聊天室/","excerpt":"聊天室服务端","text":"聊天室服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class Server &#123; /* * 运行在服务端的ServerSocket * 有两个主要作用: * 1:向系统申请对外的服务端口,客户端就是通过 * 这个端口与服务端建立连接的. * 2:监听服务端口,等待客户端连接.一旦一个客户端 * 通过Socket与服务端建立连接,那么ServerSocket * 会创建一个Socket与该客户端通讯. */ private ServerSocket server; /* * 该数组用于存放所有客户端的输出流 */// private PrintWriter[] allOut = new PrintWriter[0]; private List&lt;PrintWriter&gt; allOut = new ArrayList&lt;PrintWriter&gt;(); public Server()&#123; try &#123; /* * 创建ServerSocket的同时向系统申请 * 对外的服务端口.注意,该端口不能和 * 其他程序冲突,否则会抛出地址被占用 * 的异常. */ server = new ServerSocket(8088); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void start()&#123; try &#123; /* * ServerSocket提供方法: * Socket accept() * 该方法是一个阻塞方法,调用后即等待 * 客户端的连接,一旦一个客户端通过 * 端口连接,那么accept方法会返回一个 * Socket实例,通过这个Socket实例就 * 可以与刚连接的客户端交互了 */ while(true)&#123; System.out.println(\"等待客户端连接...\"); Socket socket = server.accept(); System.out.println(\"一个客户端连接了!\"); //启动一个线程,处理该客户端交互工作 ClientHandler handler = new ClientHandler(socket); Thread t = new Thread(handler); t.start(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Server server = new Server(); server.start(); &#125; /** * 该线程任务负责与指定Socket所对应的客户端 * 进行交互. * @author adminitartor * */ private class ClientHandler implements Runnable&#123; //当前线程通过这个Socket与对应客户端交互 private Socket socket; /** * 实例化时将对应客户端的Socket传入 * @param socket */ public ClientHandler(Socket socket)&#123; this.socket = socket; &#125; public void run()&#123; PrintWriter pw = null; try &#123; InputStream in = socket.getInputStream(); BufferedReader br = new BufferedReader( new InputStreamReader( in,\"UTF-8\" ) ); /* * 获取输出流,用于给当前客户端回复消息 */ pw = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream(), \"UTF-8\" ) ),true ); //将当前客户端对应的输出流存入共享数组 synchronized (allOut) &#123; // //1扩容数组// allOut = Arrays.copyOf(allOut, allOut.length+1);// //2将输出流存入数组// allOut[allOut.length-1] = pw; allOut.add(pw); &#125; /* * 客户端在断开连接时不同系统有不同反应 * linux的客户端断开后,br.readLine方法会 * 返回null. * windows的客户端断开连接后,br.readLine方法 * 会直接抛出异常. */ String message = null; while((message = br.readLine())!=null)&#123; System.out.println(\"客户端说:\"+message); //回复客户端// pw.println(\"客户端说:\"+message); //发送给所有客户端 synchronized (allOut) &#123;// for(int i=0;i&lt;allOut.length;i++)&#123;// allOut[i].println(\"客户端说:\"+message);// &#125; for(PrintWriter o : allOut)&#123; o.println(\"客户端说:\"+message); &#125; &#125; &#125; &#125; catch (Exception e) &#123; &#125; finally&#123; //处理客户端断开连接后的操作 //1将该客户端的输出流从共享数组中删除 synchronized (allOut) &#123;// for(int i=0;i&lt;allOut.length;i++)&#123;// if(allOut[i]==pw)&#123;// //将最后一个元素放入当前位置// allOut[i] = allOut[allOut.length-1];// //缩容// allOut = Arrays.copyOf(allOut, allOut.length-1);// break;// &#125;// &#125; allOut.remove(pw); &#125; /* * 2客户端断开连接后,服务端关闭 * 该客户端Socket,释放资源 */ try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 聊天室客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class Client &#123; /* * java.net.Socket * 套接字,封装了TCP协议.Socket提供了两条流 * 用来与服务端进行双向通讯. */ private Socket socket; /** * 构造方法,用来初始化客户端 */ public Client()&#123; try &#123; /* * 实例化Socket就是连接服务端的过程 * 参数1:服务端地址 * 参数2:服务端开启的服务端口 * * 通过服务端IP地址可以找到服务端所处 * 计算机,再通过端口找到运行在服务端 * 计算机上的服务端应用程序. */ socket = new Socket(\"localhost\",8088); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 客户端开始工作的方法 */ public void start()&#123; try &#123; //先启动线程接收服务端发送的消息 ServerHandler handler = new ServerHandler(); Thread t = new Thread(handler); t.start(); Scanner scanner = new Scanner(System.in); /* * Socket提供方法: * OutputStream getOutputStream() * 通过返回的字节输出流写出的数据会发送 * 给远端计算机,对于客户端这边而言远端 * 计算机就是服务端了. */ OutputStream out = socket.getOutputStream(); PrintWriter pw = new PrintWriter( new BufferedWriter( new OutputStreamWriter( out,\"UTF-8\" ) ),true ); while(true)&#123; String line = scanner.nextLine(); pw.println(line); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.start(); &#125; /** * 该线程负责循环接收服务端发送过来的消息. * 给服务端发送消息与接收服务端发过来的消息 * 要放在两个不同的线程要运行,这样才能做到 * 互相不干扰. * @author adminitartor * */ private class ServerHandler implements Runnable&#123; public void run()&#123; try &#123; BufferedReader br = new BufferedReader( new InputStreamReader( socket.getInputStream(), \"UTF-8\" ) ); String message = null; while((message = br.readLine())!=null)&#123; System.out.println(message); &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125;","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Demo","slug":"Demo","permalink":"http://anqingliu.github.io/tags/Demo/"}]},{"title":"IO流","slug":"IO流","date":"2019-05-01T14:58:27.833Z","updated":"2019-05-01T16:07:33.529Z","comments":true,"path":"2019/05/01/IO流/","link":"","permalink":"http://anqingliu.github.io/2019/05/01/IO流/","excerpt":"IO流 java提供了标准的IO操作,即:输入与输出","text":"IO流 java提供了标准的IO操作,即:输入与输出 IO的作用是可以让我们的程序与外界进行数据交换.比如从网络读写数据,读取键盘数据,读写文件数据等等. 标准的IO根据将功能按照方向划分 输入:从外界到程序中的过程,这是”读”的过程 输出:从程序发送至外界的过程,这是”写”的过程 学习IO的重点:理解流链接操作,通过应用流连接,按照需求组合高级流与低级流,完成读写操作. 流分为:节点流(低级流),处理流(高级流) 节点流:实际链接程序与另一端的管道,负责在两端之间传送数据.注意:读写一定是建立在节点流的基础上进行的. 处理流:不能独立存在,可以链接在其他流上,处理流自带某种对数据的加工操作,所以数据流经该流会对这些数据进行处理,这样可以简化我们对数据的处理操作. java.io.InputStream 所有字节输入流的父类,是一个抽象类,规定了所有字节输入流都必须具备的读取字节的方法 java.io.OutputStream 所有字节输出流的父类,是一个抽象类,规定了所有字节输出流都必须具备的写出字节的方法 文件流 文件流是一套低级流,作用是读写文件数据. 文件输出流支持的两种写模式: 覆盖写操作,即:若写出的文件有数据,则将原有数据全部删除,将本次通过流写出的内容作为文件数据.FileOutputStream(String path), FileOutputStream(File file) 追加写操作,若文件有数据则全部保留,从该文件末尾追加内容FileOutputStream(String path,boolean append)FileOutputStream(File file,boolean append) 文件流与RandomAccessFile的对比: 1:论功能是一致的,都是用来读写文件数据 2:RAF对于文件即可读也可写,但是文件流不行,文件输入流只用来读文件数据,文件输出流用来向文件中写入数据 流的特点是顺序读写操作,即:读写是不能回退的.RAF是随机读写操作,因为依靠指针位置进行读写,所以可以通过操作指针对文件任意位置随意读写.","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"流的注册和读取","slug":"流的注册和读取","date":"2019-05-01T07:51:06.257Z","updated":"2019-05-03T15:28:10.970Z","comments":true,"path":"2019/05/01/流的注册和读取/","link":"","permalink":"http://anqingliu.github.io/2019/05/01/流的注册和读取/","excerpt":"完成用户注册功能 用user.dat文件保存用户信息 每个用户的信息包括:用户名,密码,昵称,年龄 其中年龄是int值,其余都是字符串.","text":"完成用户注册功能 用user.dat文件保存用户信息 每个用户的信息包括:用户名,密码,昵称,年龄 其中年龄是int值,其余都是字符串. 1234567891011121314151617181920212223242526272829303132333435public class Test1 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(\"user.dat\",\"rw\"); //先将指针移动到文件末尾,以便追加新记录 raf.seek(raf.length()); String name = \"测试\"; String password = \"123456\"; String nickname = \"测\"; int age = 18; /* * 每条记录占用100字节,其中用户名,密码, * 昵称各占32字节,int型的age占4字节. * 数据\"留白\"的目的是便于后期修改信息. */ //写用户名 byte[] data = name.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data);//一次写了32字节 data = password.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data); data = nickname.getBytes(\"UTF-8\"); data = Arrays.copyOf(data, 32); raf.write(data); raf.writeInt(age); System.out.println(\"注册完毕!\"); raf.close(); &#125;&#125; 将每个用户信息输出123456789101112131415161718192021222324public class Test2 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(\"user.dat\",\"r\"); /* * 将每个用户信息输出格式:user,pwd,nick,age */ for(int i=0;i&lt;raf.length()/100;i++)&#123; //读用户名 byte[] data = new byte[32]; raf.read(data); String name = new String(data,\"UTF-8\").trim(); //读密码 raf.read(data); String pwd = new String(data,\"UTF-8\").trim(); //读昵称 raf.read(data); String nickname = new String(data,\"UTF-8\").trim(); //读年龄 int age = raf.readInt(); System.out.println(name+\",\"+pwd+\",\"+nickname+\",\"+age); &#125; &#125;&#125;","categories":[{"name":"2019年5月","slug":"2019年5月","permalink":"http://anqingliu.github.io/categories/2019年5月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"鼠标移动自动闪开","slug":"鼠标移动自动闪开","date":"2019-04-29T15:13:31.399Z","updated":"2019-04-29T15:21:04.657Z","comments":true,"path":"2019/04/29/鼠标移动自动闪开/","link":"","permalink":"http://anqingliu.github.io/2019/04/29/鼠标移动自动闪开/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;body&gt; &lt;canvas id=\"pane\" width=\"1024\" height=\"520\"&gt;&lt;/canvas&gt; &lt;script&gt; var no = new Image(); no.src = \"images/no.png\"; var canvas = document.getElementById('pane'); var ctx = canvas.getContext('2d'); var btnN = new Btn(564,402,686,294,no); setInterval(function()&#123; btnN.paintBtn(); &#125;); canvas.onmousemove = function(evt)&#123; var e = evt||event; if(btnN.contains(e.x+331, e.y+138))&#123;//鼠标靠近图片x331,y138的地方 btnN.x = Math.floor((Math.random() * 190) + 648); btnN.y = Math.floor((Math.random() * 190) + 210); &#125; &#125;; function Btn(pointx,pointy,x,y,say)&#123; this.x=x; this.y=y; this.pointx=pointx; this.pointy=pointy; this.paintBtn=function()&#123; ctx.save();//保存当前画布状态 ctx.translate(this.x, this.y);//函数用于在二维空间中移动一个元素。 var a = Math.atan((this.y- this.pointy)/(this.x - this.pointx)); a=a&lt;0?a+Math.PI:a; ctx.rotate(a);//旋转 ctx.restore();//恢复最近一近的画布保存状态 ctx.drawImage(say,this.x-say.naturalWidth/2,this.y-say.naturalHeight/2); &#125;; this.contains = function(ex,ey)&#123; return Math.sqrt(Math.pow((ex-this.x),2)+Math.pow((ey-this.y),2))&lt;50; &#125;; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]},{"title":"猜数字小游戏","slug":"java猜数字游戏","date":"2019-04-27T14:06:25.950Z","updated":"2019-04-27T14:16:24.106Z","comments":true,"path":"2019/04/27/java猜数字游戏/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/java猜数字游戏/","excerpt":"介绍 随机生成一个数字,然后开始猜的一个游戏","text":"介绍 随机生成一个数字,然后开始猜的一个游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;public class Guessing &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); char[] chs = generate(); //获取随机字符数组 //System.out.println(chs); //作弊 int count = 0; //猜错的次数 while(true)&#123; //自造死循环 System.out.println(\"猜吧!\"); String str = scan.nextLine().toUpperCase(); //接收用户输入的字符串并转换为大写字母 if(str.equals(\"EXIT\")) &#123; //判断字符串内容是否是EXIT System.out.println(\"下次再来吧!\"); break; &#125; char[] input = str.toCharArray(); //将字符串转换为字符数组 int[] result = check(chs,input); //对比:随机字符数组与用户输入的字符数组 if(result[0]==chs.length) &#123; int score = 100*chs.length-10*count; //1个字符100分，猜错一次扣10分 System.out.println(\"恭喜你猜对了，得分为:\"+score); break; &#125;else &#123; count++; System.out.println(\"字符对个数为:\"+result[1]+\"，位置对个数为:\"+result[0]); &#125; &#125; &#125; //生成随机字符数组chs public static char[] generate() &#123; char[] chs = new char[5]; //随机字符数组 char[] letters = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' &#125;; //随机字符范围数组 boolean[] flags = new boolean[letters.length]; //标记数组 for(int i=0;i&lt;chs.length;i++) &#123; //遍历随机字符数组 int index; do &#123; index = (int)(Math.random()*letters.length); //随机下标(0到25之间) &#125;while(flags[index]==true); //下标index对应的标记为true，表示对应字符已经使用过，则重新生成index下标 chs[i] = letters[index]; //基于下标index获取对应的字符并赋值给chs中的每一个元素 flags[index] = true; //将下标index对应的标记修改为true，表示对应字符已存过 &#125; return chs; &#125; //对比:随机字符数组chs与用户输入的字符数组input public static int[] check(char[] chs,char[] input) &#123; int[] result = new int[2]; //对比结果(0,0)--假设result[1]为字符对，result[0]为位置对 for(int i=0;i&lt;chs.length;i++) &#123; //遍历随机字符数组 for(int j=0;j&lt;input.length;j++) &#123; //遍历用户输入的字符数组 if(chs[i]==input[j]) &#123; //字符对 result[1]++; //字符对个数增1 if(i==j) &#123; //位置对 result[0]++; //位置对个数增1 &#125; break; //剩余input元素不再参与比较了 &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://anqingliu.github.io/tags/游戏/"}]},{"title":"java基本数据类型","slug":"java基本数据类型","date":"2019-04-27T11:32:23.029Z","updated":"2019-04-27T13:55:27.635Z","comments":true,"path":"2019/04/27/java基本数据类型/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/java基本数据类型/","excerpt":"基本数据类型","text":"基本数据类型 int:整形,4个字节 整数直接量默认为int类型，但不能超范围，超范围则编译错误 两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入) 整数运算时若超出范围会发生溢出，溢出是需要避免的 long:长整型，8个字节 长整型的直接量，需在数字后加L或l 运算时若有可能溢出，建议在第1个数字后加L System.currentTimeMillis()用于获取自1970.1.1零时到此时此刻的毫秒数 double:浮点型，8个字节(精确运算场合不能用double) 浮点数直接量默认为double型，若想表示float需在数字后加F或f double和float型数据参与运算时，有可能会出现舍入误差 boolean:布尔型，1个字节 只能取值为true或false char:字符型，2个字节 采用Unicode字符集编码，每个字符对应一个码,表现的形式是字符char，但本质上是码int(0到65535之间),&#39;a&#39;=97 &#39;A&#39;=65 &#39;0&#39;=48 字符型直接量必须放在单引号中，只能有一个 特殊符号需要通过\\来转义 财务ERP—————–BigDecimal 基本数据类型间的转换: 数据类型从小到大依次为:byte-short-int(char)-long-float-double 自动类型转换:小类型到大类型 强制类型转换:大类型到小类型 语法: (要转换成为的数据类型)变量,强转有可能会发生溢出或精度的丢失 整数直接量可以直接赋值给byte、short、char，但不能超出范围 byte、short、char型数据参与运算时，先一律转换为int再运算 命名 只能包含字母、数字、_和$符，并且不能以数字开头 严格区分大小写 不能使用关键字 可以中文命名，但不建议,建议”英文的见名知意”、”驼峰命名法” 例子 int的最大值和最小值的变换 12int balance = 2147483647;balance = balance+1; //-2147483648(最小值)","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"java基础","slug":"java基础","date":"2019-04-27T08:14:47.338Z","updated":"2019-04-27T11:54:56.637Z","comments":true,"path":"2019/04/27/java基础/","link":"","permalink":"http://anqingliu.github.io/2019/04/27/java基础/","excerpt":"Java开发环境 编译运行过程 编译期:.java源文件,经过编译,生成.class字节码文件 运行期: JVM加载.class并运行.class","text":"Java开发环境 编译运行过程 编译期:.java源文件,经过编译,生成.class字节码文件 运行期: JVM加载.class并运行.class 特点:跨平台,一次编程到处使用(显示中一般需要重新编写) JVM:java虚拟机,加载.class并运行.class JRE:java运行环境除了包含JVM以外还包含了运行java程序所必须的环境 JVM+java系统类库(API) JDK:java开发工具包,除了包含JRE以外还包含了开发java程序所必须的命令工具 JDK=JRE+编译,运行等命令工具 运行java程序的最小环境是JRE 开发java程序的最小环境是JDK ####配置环境变量 JVAV_HOME:指向jdk的安装路径 CLASSPATH:表示类的搜索路径 PATH:指向jdk下的bin目录","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://anqingliu.github.io/tags/Java/"}]},{"title":"svn的搭建和使用","slug":"离线服务器搭建svn并使用","date":"2019-04-21T10:19:16.932Z","updated":"2019-04-27T03:21:30.990Z","comments":true,"path":"2019/04/21/离线服务器搭建svn并使用/","link":"","permalink":"http://anqingliu.github.io/2019/04/21/离线服务器搭建svn并使用/","excerpt":"因为公司使用的是内网，所以只能用下载安装包的办法来搭建 一、需要下载的安装包 subversion-1.11.1.tar.gz sqlite-autoconf-3280000.tar.gz apr-1.7.0.tar.gz apr-util-1.6.1.tar.gz zlib 1.2.11.tar.xz 当安装apr-util出错时，需要安装expat_2.0.1.orig.tar.gz","text":"因为公司使用的是内网，所以只能用下载安装包的办法来搭建 一、需要下载的安装包 subversion-1.11.1.tar.gz sqlite-autoconf-3280000.tar.gz apr-1.7.0.tar.gz apr-util-1.6.1.tar.gz zlib 1.2.11.tar.xz 当安装apr-util出错时，需要安装expat_2.0.1.orig.tar.gz 二、解压当前包 tar -tar -xzvf 需要解压的包 在home下新建svn文件夹 三、开始安装 安装apr cd apr-1.7.0 ./configure prefix=/home/svn/apr-1.7.0 make make install 安装 apr-uill cd apr-util-1.6.1 ./configure prefix=/home/svn/apr-util-1.6.1 --with-apr=/home/svn/apr-1.7.0 make make install 当apr-util出错时 cd expat-2.0.1 ./configure make make install 重新安装apr-util 安装zlib cd zlib-1.2.11 ./configure prefix=/home/svn/zlib-1.2.11 make make install 安装sqllite mv sqlite-autoconf-3280000 ./subversion-1.9.7/sqlite-amalgamation 安装subversion cd subversion-1.11.1 ./configure prefix=/home/svn/subversion-1.11.1 --with-apr=/home/svn/apr-1.7.0 --with-apr-util=/home/svn/apr-util-1.6.1 --with-zlib=/home/svn/zlib make make install 四、将svn加入path，并验证安装是否成功 cd vim .bash_profile :i PATH=/home/svn/subversion-1.11.1/bin:$PATH 保存退出 . .bash_profile 在ect/bash_profile里也加一下path . profile 验证 svnserve --version 出现版本号即验证成功 五、配置仓库 mkdir -p myproject svnadmin create /home/svn/myproject 修改配置文件 cd myproject/conf vim subversion.conf 将以下几项前的#删除，并顶格编写 anon-access = none # 使非授权用户无法访问 auth-access = write # 使授权用户有写权限 password-db = /opt/svndata/repos/conf/passwd # 指明密码文件路径 authz-db = /opt/svndata/repos/conf/authz # 访问控制文件 realm = /opt/svndata/repos # 认证命名空间，subversion会在认证提示里显示，并且作为凭证缓存的关键字. 保存并退出 vim passwd 输入以下内容： admin = admin username2 = password2 可以添加多个，此为用户名密码对。保存并退出 vim authz &lt;用户组名&gt; = &lt;用户1&gt;,&lt;用户2&gt;, 其中，1个用户组可以包含1个或多个用户，用户间以逗号分隔。 别忘了[/]和* = rw 保存退出 六、启动服务 svnserve -d 版本库路径 --listen 端口号 -r /home/svn/myproject 例如svnserve -d --listen-port 3690 -r /home/svn/myproject 启动后，可在进程中查找是否已启动svn服务ps - ef|grep svn 七、开通端口，开通防火墙端口 这步我没操作，不过看网上的大大有写，具体可以看大大们的 八、访问服务 安装TortoiseSVN.msi,新建一个文件夹，右键，选择svn检测，输入svn://SVN服务器的IP地址,点击确定，弹出一个框，输入账号密码，账号密码是第五步设置的那几个 把你团队需要的东西放进新建的文件夹，add后commit就行了 九、最后感言 安装不易，且安且珍惜","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://anqingliu.github.io/tags/软件/"}]},{"title":"博客搭建过程","slug":"博客搭建过程","date":"2019-04-07T13:48:08.413Z","updated":"2019-10-27T11:30:44.959Z","comments":true,"path":"2019/04/07/博客搭建过程/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/博客搭建过程/","excerpt":"在假期搭建了博客，功能还在完善，但基本可以使用 首先： 我先去bilibili学习了一下搭建博客的视频 跟着视频就能做出一个成功的范例，-。-","text":"在假期搭建了博客，功能还在完善，但基本可以使用 首先： 我先去bilibili学习了一下搭建博客的视频 跟着视频就能做出一个成功的范例，-。- 然后： 想着把内容记下来，然后去找了一下相关的教程，重新做了一遍 我是用window 7安装的hexo，用系统自带的cmd，先去hexo官网下载hexo安装包 用淘宝镜像源$ npm install -g cnpm --registry=https://registry.npm.taobao.org，不仅因为速度的原因，在后面的操作中，用npm下载失败而用cnpm下载成功 $ cnpm install -g hexo-cli安装hexo 进入放置Blog的一个空白的文件夹，hexo init初始化博客 hexo s启动博客，打开浏览器，输入http://localhost:4000就可以打开你的博客了 进入source\\_posts,新建一个md文件，就是第一篇博客 然后hexo g生成静态文件 接着： 新建一个 github的账号，新建一个和你账号名一样的仓库，以我为例anqingliu.github.io 然后下载一个插件cnpm install hexo-deployer-git --save 打开hexo文件里的_config.yml 写上你自己博客的地址，如果第一次上传，需要你的账号和密码 123type: gitrepo: git@github.com:Anqingliu/Anqingliu.github.io.gitbranch: master 用hexo d上送你的博客 最后： 选一个你喜欢的主题，用git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 修改你的_config.yml文件为theme: material-x hexo clean先清除一下原有格式化 hexo g重新生成 hexo d上送到github","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]},{"title":"测试发文","slug":"Test","date":"2019-04-07T13:34:33.646Z","updated":"2019-04-27T03:19:35.045Z","comments":true,"path":"2019/04/07/Test/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/Test/","excerpt":"测试发文","text":"测试发文 你好，安晴！","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://anqingliu.github.io/tags/测试/"}]},{"title":"Hexo的简介和使用","slug":"hello-world","date":"2019-04-07T04:18:59.652Z","updated":"2019-04-27T03:21:38.021Z","comments":true,"path":"2019/04/07/hello-world/","link":"","permalink":"http://anqingliu.github.io/2019/04/07/hello-world/","excerpt":"注：这个博客使用了hexo搭建 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"注：这个博客使用了hexo搭建 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"2019年4月","slug":"2019年4月","permalink":"http://anqingliu.github.io/categories/2019年4月/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://anqingliu.github.io/tags/前端/"}]}]}